commit 4e1a6f9d8f2a49403bbd00b8c8e5324048fb84d4
Author: Ivan Maidanski <ivmai@mail.ru>
Date:   Thu Sep 15 18:40:21 2016 +0300

    Fix calloc_explicitly_typed in case of lb*n overflow
    
    * typd_mlc.c: Include limits.h (for SIZE_MAX).
    * typd_mlc.c (GC_SIZE_MAX, GC_SQRT_SIZE_MAX): New macro (same as in
    malloc.c).
    * typd_mlc.c (GC_calloc_explicitly_typed): Return NULL if lb * n
    overflows (same algorithm as in calloc defined in malloc.c); eliminate
    lb *= n code duplication.

Index: libgc-7.2d/typd_mlc.c
===================================================================
--- libgc-7.2d.orig/typd_mlc.c	2022-03-29 16:15:25.020302787 +0200
+++ libgc-7.2d/typd_mlc.c	2022-03-29 16:16:23.584285762 +0200
@@ -649,6 +649,15 @@
    return((void *) op);
 }
 
+#include <limits.h>
+#ifdef SIZE_MAX
+# define GC_SIZE_MAX SIZE_MAX
+#else
+# define GC_SIZE_MAX (~(size_t)0)
+#endif
+
+#define GC_SQRT_SIZE_MAX ((1U << (WORDSZ / 2)) - 1)
+
 GC_API void * GC_CALL GC_calloc_explicitly_typed(size_t n, size_t lb,
                                                  GC_descr d)
 {
@@ -663,15 +672,18 @@
 
     descr_type = GC_make_array_descriptor((word)n, (word)lb, d,
                                           &simple_descr, &complex_descr, &leaf);
+    if ((lb | n) > GC_SQRT_SIZE_MAX /* fast initial check */
+        && lb > 0 && n > GC_SIZE_MAX / lb)
+      return NULL; /* n*lb overflow */
+    lb *= n;
     switch(descr_type) {
         case NO_MEM: return(0);
-        case SIMPLE: return(GC_malloc_explicitly_typed(n*lb, simple_descr));
+        case SIMPLE:
+            return GC_malloc_explicitly_typed(lb, simple_descr);
         case LEAF:
-            lb *= n;
             lb += sizeof(struct LeafDescriptor) + TYPD_EXTRA_BYTES;
             break;
         case COMPLEX:
-            lb *= n;
             lb += TYPD_EXTRA_BYTES;
             break;
     }
